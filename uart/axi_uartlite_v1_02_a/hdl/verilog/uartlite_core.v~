//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? ??? 5 2018 16:24:54
//
//      Input file      : 
//      Component name  : uartlite_core
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module uartlite_core(Clk, Reset, bus2ip_data, bus2ip_rdce, bus2ip_wrce, bus2ip_cs, ip2bus_rdack, ip2bus_wrack, ip2bus_error, SIn_DBus, RX, TX, Interrupt);
   parameter [32*8:1]     C_FAMILY = "virtex6";
   parameter              C_S_AXI_ACLK_FREQ_HZ = 100_000_000;
   parameter              C_BAUDRATE = 9600;
   parameter [3:0]        C_DATA_BITS = 8;
   parameter [0:0]        C_USE_PARITY = 0;
   parameter [0:0]        C_ODD_PARITY = 0;
   input                  Clk;
   input                  Reset;
   input [0:7]            bus2ip_data;
   input [0:3]            bus2ip_rdce;
   input [0:3]            bus2ip_wrce;
   input                  bus2ip_cs;
   output                 ip2bus_rdack;
   output                 ip2bus_wrack;
   output                 ip2bus_error;
   output [0:7]           SIn_DBus;
   reg [0:7]              SIn_DBus;
   input                  RX;
   output                 TX;
   output                 Interrupt;
   reg                    Interrupt;
   
   
   function integer CALC_RATIO;
      input                  C_S_AXI_ACLK_FREQ_HZ;
      integer                C_S_AXI_ACLK_FREQ_HZ;
      input                  C_BAUDRATE;
      integer                C_BAUDRATE;
      
      parameter              C_BAUDRATE_16_BY_2 = (16 * C_BAUDRATE)/2;
      parameter              REMAINDER = C_S_AXI_ACLK_FREQ_HZRem(16 * C_BAUDRATE);
      parameter              RATIO = C_S_AXI_ACLK_FREQ_HZ/(16 * C_BAUDRATE);
   begin
      
      if (C_BAUDRATE_16_BY_2 < REMAINDER)
         CALC_RATIO = (RATIO + 1);
      else
         CALC_RATIO = RATIO;
   end
   endfunction
   
   parameter              RATIO = CALC_RATIO(C_S_AXI_ACLK_FREQ_HZ, C_BAUDRATE);
   
   reg [0:7]              status_reg;
   
   wire                   en_16x_Baud;
   reg                    enable_interrupts;
   reg                    reset_RX_FIFO;
   wire [0:C_DATA_BITS-1] rx_Data;
   wire                   rx_Data_Present;
   wire                   rx_Buffer_Full;
   wire                   rx_Frame_Error;
   wire                   rx_Overrun_Error;
   wire                   rx_Parity_Error;
   reg                    clr_Status;
   reg                    reset_TX_FIFO;
   wire                   tx_Buffer_Full;
   wire                   tx_Buffer_Empty;
   reg                    tx_Buffer_Empty_Pre;
   reg                    rx_Data_Present_Pre;
   
   assign ip2bus_rdack = bus2ip_rdce[0] | bus2ip_rdce[2] | bus2ip_rdce[1] | bus2ip_rdce[3];
   
   assign ip2bus_wrack = bus2ip_wrce[1] | bus2ip_wrce[3] | bus2ip_wrce[0] | bus2ip_wrce[2];
   
   assign ip2bus_error = ((bus2ip_rdce[0] & (~rx_Data_Present)) | (bus2ip_wrce[1] & tx_Buffer_Full));
   
   axi_uartlite_v1_02_a.baudrate #(RATIO) BAUD_RATE_I(.clk(Clk), .reset(Reset), .en_16x_baud(en_16x_Baud));
   
   always @(*) status_reg[7] <= rx_Data_Present;
   always @(*) status_reg[6] <= rx_Buffer_Full;
   always @(*) status_reg[5] <= tx_Buffer_Empty;
   always @(*) status_reg[4] <= tx_Buffer_Full;
   always @(*) status_reg[3] <= enable_interrupts;
   
   
   always @(posedge Clk)
   begin: CLEAR_STATUS_REG
      
      begin
         if (Reset == 1'b1)
            clr_Status <= 1'b0;
         else
            clr_Status <= bus2ip_rdce[2];
      end
   end
   
   
   always @(posedge Clk)
   begin: RX_OVERRUN_ERROR_DFF
      
      begin
         if ((Reset == 1'b1) | (clr_Status == 1'b1))
            status_reg[2] <= 1'b0;
         else if (rx_Overrun_Error == 1'b1)
            status_reg[2] <= 1'b1;
      end
   end
   
   
   always @(posedge Clk)
   begin: RX_FRAME_ERROR_DFF
      
      begin
         if (Reset == 1'b1)
            status_reg[1] <= 1'b0;
         else
            if (clr_Status == 1'b1)
               status_reg[1] <= 1'b0;
            else if (rx_Frame_Error == 1'b1)
               status_reg[1] <= 1'b1;
      end
   end
   
   generate
      if (C_USE_PARITY == 1)
      begin : USING_PARITY
         
         always @(posedge Clk)
         begin: RX_PARITY_ERROR_DFF
            
            begin
               if (Reset == 1'b1)
                  status_reg[0] <= 1'b0;
               else
                  if (clr_Status == 1'b1)
                     status_reg[0] <= 1'b0;
                  else if (rx_Parity_Error == 1'b1)
                     status_reg[0] <= 1'b1;
            end
         end
      end
   endgenerate
   
   generate
      if (C_USE_PARITY == 0)
      begin : NO_PARITY
         always @(*) status_reg[0] <= 1'b0;
      end
   endgenerate
   
   
   always @(posedge Clk)
   begin: CTRL_REG_DFF
      
      begin
         if (Reset == 1'b1)
         begin
            reset_TX_FIFO <= 1'b1;
            reset_RX_FIFO <= 1'b1;
            enable_interrupts <= 1'b0;
         end
         else if (bus2ip_wrce[3] == 1'b1)
         begin
            reset_RX_FIFO <= bus2ip_data[6];
            reset_TX_FIFO <= bus2ip_data[7];
            enable_interrupts <= bus2ip_data[3];
         end
         else
         begin
            reset_TX_FIFO <= 1'b0;
            reset_RX_FIFO <= 1'b0;
         end
      end
   end
   
   
   always @(posedge Clk)
   begin: TX_BUFFER_EMPTY_DFF_I
      
      begin
         if (Reset == 1'b1)
            tx_Buffer_Empty_Pre <= 1'b0;
         else
            if (bus2ip_wrce[1] == 1'b1)
               tx_Buffer_Empty_Pre <= 1'b0;
            else
               tx_Buffer_Empty_Pre <= tx_Buffer_Empty;
      end
   end
   
   
   always @(posedge Clk)
   begin: RX_BUFFER_DATA_DFF_I
      
      begin
         if (Reset == 1'b1)
            rx_Data_Present_Pre <= 1'b0;
         else
            if (bus2ip_rdce[0] == 1'b1)
               rx_Data_Present_Pre <= 1'b0;
            else
               rx_Data_Present_Pre <= rx_Data_Present;
      end
   end
   
   
   always @(posedge Clk)
   begin: INTERRUPT_DFF
      
      begin
         if (Reset == 1'b1)
            Interrupt <= 1'b0;
         else
            Interrupt <= enable_interrupts & ((rx_Data_Present & (~rx_Data_Present_Pre)) | (tx_Buffer_Empty & (~tx_Buffer_Empty_Pre)));
      end
   end
   
   
   always @(status_reg or bus2ip_rdce[2] or bus2ip_rdce[0] or rx_Data)
   begin: READ_MUX
      if (bus2ip_rdce[2] == 1'b1)
         SIn_DBus <= status_reg;
      else if (bus2ip_rdce[0] == 1'b1)
         SIn_DBus[(8 - C_DATA_BITS):7] <= rx_Data;
      else
         SIn_DBus <= {8{1'b0}};
   end
   
   
   axi_uartlite_v1_02_a.uartlite_rx #(C_FAMILY, C_DATA_BITS, C_USE_PARITY, C_ODD_PARITY) UARTLITE_RX_I(.clk(Clk), .reset(Reset), .en_16x_baud(en_16x_Baud), .rx(RX), .read_rx_fifo(bus2ip_rdce[0]), .reset_rx_fifo(reset_RX_FIFO), .rx_data(rx_Data), .rx_data_present(rx_Data_Present), .rx_buffer_full(rx_Buffer_Full), .rx_frame_error(rx_Frame_Error), .rx_overrun_error(rx_Overrun_Error), .rx_parity_error(rx_Parity_Error));
   
   
   axi_uartlite_v1_02_a.uartlite_tx #(C_FAMILY, C_DATA_BITS, C_USE_PARITY, C_ODD_PARITY) UARTLITE_TX_I(.clk(Clk), .reset(Reset), .en_16x_baud(en_16x_Baud), .tx(TX), .write_tx_fifo(bus2ip_wrce[1]), .reset_tx_fifo(reset_TX_FIFO), .tx_data(bus2ip_data[8 - C_DATA_BITS:7]), .tx_buffer_full(tx_Buffer_Full), .tx_buffer_empty(tx_Buffer_Empty));
   
endmodule
